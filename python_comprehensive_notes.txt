PYTHON NOTES:

num2 = 235
print('Num2 = ' + str(num2) + ' is smallest')
# In the above code snippet, the str(num2) is to CAST the 'int' data into 'str' data. Note that in Python, there is no Implicit Type Conversion.

Program1: small_of_two_nums.py
num1 = 7
num2 = 5

if num1 < num2:
    print('Num1 = ', num1, ' is smallest')
else:
    print('Num2 = ' + str(num2) + ' is smallest')
--------------------
123
45

ascii
256 ascii characters
0 - 255

bit
nibble
0000 to 1111
byte
0 to 1111 1111
--------------------
print('Enter the first number:')
number1 = int(input())
number2 = int(input('Enter the second number: '))

print(type(number1))

if number1 < number2:
    print('Num1 = ', number1, ' is smallest')
else:
    print('Num2 = ' + str(number2) + ' is smallest')
---------------------
# Program to check if a number is Even.

input_num = int(input('Enter a number to check if it is Even'))

if input_num % 2 == 0:
    print(f'{input_num} is an Even number')
----------------------
Arithmetic Operators:
+ - * / %
All are binary operators
Used with Infix Notation
Input are numbers
Output is number
Type of both the operands must be same
2 + 17 - 15
Arithmetic operators/operations have Left to Right Associtivity
2 - 17 * 15
The higher precedence operators/operations happens 1st, even though the operator appreas lately in the arithmetic expression. In the above expression, 17 * 15 is calculated 1st.
The intermediatre result of an arithmetic expression is stored in the special purpose register named "Accumalator"

34 + 45
34 + (-45)

25 + 25.55


num1 = 34
num2 = -45


0010 0010
1 * 2(5) + 2
= 32 + 2 
= 34

Now take -45
take its absolute
take its 2's Compliment
0010 1101
1101 0010

1101 0011
-1 * 2(7) + 1 * 2(6) + 16 + 3
-128 + 64 + 19
-64 + 19
= -45
-----------------------
Relational Operators:
< > <= >= != ==

for var_i from 1 to 10 do:
	print('Yesterday was Basant Panchami')

for(i = 1; i <= 10; i++) # closed interval
	print('Yesterday was Basant Panchami')
	
for(i = 1; i < 11; i++) # open interval (Right Open)
	print('Yesterday was Basant Panchami')
--------------------------------
(10, 20) Open Interval
(10, 30] Left Open
[30, 50] Closed Interval
--------------------------
Logical Operators:
and or not (In Python the logical operators are SHORT-CIRCUITED operators)

& && | || !
In Python we have only 3: and or not (Short circuiting operators)
oc_c1   oc_c2   oc_c1 and oc_c2
0		0			0
0		1			0
1		0			     
-------------------------
# Find the biggest of 3 distinct numbers

input_num1 = int(input('Enter 1st number: '))
input_num2 = int(input('Enter 2nd number: '))
input_num3 = int(input('Enter 3rd number: '))

if input_num1 > input_num2 and input_num1 > input_num3:
    print(f'Num1 = {input_num1} is the biggest number')
elif input_num2 > input_num3:
    print(f'Num2 = {input_num21} is the biggest number')
else:
    print(f'Num3 = {input_num3} is the biggest number')
-----------------------
Accept the avg_score from the student and print the result as follows:
0  - 49 : Fail
50 - 74 : SC
75 - 90 : FC
91 - 100: Distiction
Also check for invalid input.

print('Student Result Application\n---------------------------')
avg_score = int(input('Enter your average score: '))

if avg_score < 0 or avg_score > 100:
    print('Invalid Average Scored entered')
elif avg_score <= 49:
    print("Result is Fail")
elif avg_score <= 74:
    print("Result is Second Class")
elif avg_score <= 90:
    print("Result is First Class")
else:
    print("Result is Distiction")
----------------------
HOW TO SOLVE A PROBLEM AND ARRIVE WITH A PROGRAM

1. Understand the problem, assertain the I/P data and the O/P data. Focus on the required information and isolate the unwanted information if any.

2. Find the solution for the given problem mathematically with a specific algorithm or trial and error method or backtracking or some other way.

3. Write the Algorithm (Sentences). Each step/sentence must be un-ambigious(discriptive), Atomic and simple and finite.

4. Write the Fake-code (Pseudocode) if required.

5. Code it.  
------------------------
CRUD operations (2-tier Architecture and above projects. Web Apps)
C - create (INSERT ONE RECORD / row / object / tuple / document)
R - Read / Retrive / Search (Read One record using ID)
R - Read / Retrive / Search (List all / Read All)
U - Update (update one record based on a key/ID)
D - Delete (Delete one record based on a key/ID)
--------------------------
Accept a number from the user and check if it is a Perfect Square

num = 45
45    6.72    6    36
121   11.0    11   121

1. Read the input number NUM
2. Find Root of NUM and store it in ROOT
3. Convert ROOT into int value
4. Multiply ROOT with ROOT and check if the Product is same as NUM
	if Yes: Print: NUM is a PS
	if No : Print: Num is not a PS

Input NUM
ROOT = squre_root(NUM)
ROOT = int(ROOT)
if ROOT * ROOT is NUM then
	print: NUM is a PS
else:
	print: NUM is not a PS

import math

input_number = int(input('Enter a number to check if it is a Perfect Square: '))

# root_number = int(math.sqrt(input_number))
root_number = math.floor(math.sqrt(input_number))

if root_number * root_number == input_number:
    print(f'{input_number} is a Perfect Square')
else:
    print(f'{input_number} is Not a Perfect Square')
----------------------------
ITERATIVE PROBLEMS:

# Print the Math table of a number for upto multiples of 20.

input_num = int(input('Enter a number to print its Math table: '))

for i in range(1, 21):
    print('%d * %02d = %03d'%(input_num, i, input_num*i))

2.
Find sum of the series:
n + n2 + n3 + upto 10 terms
3.
Find sum of the series:
1 - n + n2 - n3 + upto M terms
4.
Find sum of the series:
1 - n/3 + n2/5 - n4/7 + n8/9 ....
(1<n<5 and 1<m<10)
5.
Count the number of digits in a number
6.
Find sum of Odd placed digits in a number
7.
Find sum of Even digits in a number
8.
Find sum of Even Placed Odd Digits in a number
9.
Print the Nth Prime number
10.
Check if the sum of Prime digits in a number is a Prime number
11.
Print Nth term of the following series:
1 2 2 3 3 5 5 7 8 11 13 13
-----------------------------------
Find sum of Even Placed Odd Digits in a number
1. Read NUM
2. if NUM is less than 10 then
	Print Result = NUM
3. else do the following:
	sum1 = 0 
	sum2 = 0
	count_of_digits = 0
	switch = true
	while NUM is greater than Zero:
		remainder_digit = NUM // 10
		if switch:
			sum1 += remainder_digit
		else:
			sum2 += remainder_digit
		switch = !switch
		count_of_digits += 1
	if count_of_digits % 2 == 0:	
		Result = sum2
	else:
		Result = sum1
-----------------------------------
# Find sum of the series:
# 1 - n/3 + n2/5 - n4/7 + n8/9 ....
# n - n2/3 + n4/5 - n8/7 .....
# (1<n<5 and 1<m<10)
'''
1  n  n2  n4  n8
n(0) n(1) n(2) n(4) n(8) 

0   1    2    4    8
0 2(0) 2(1) 2(2) 2(3)

1  3  5  7
2i is Even 

2i-1 or 2i+1
'''

n = int(input('Enter the N value: '))
m = int(input('Enter numbers of terms in the series: '))

if (n <= 1 or n >= 5) and (m <= 1 or m >= 10):
    print('Invalid data entered')
    exit('End of Program')

# For valid input data:
sum = 0
numerator = 1
denominator = 1
for i in range(m):
    if i == 0:
        sum = 1
        print('sum = ', sum, 'i = ', i)
        continue # goes to next iteration of the loop
    else:
        numerator = n ** 2 ** (i-1)
        denominator = 2 * i + 1
    term = ( (-1) ** i) * numerator / denominator
    sum += term
    print('sum = ', sum, 'i = ', i)

print('Sum of the terms is ', sum)

'''
1 - n/3 + n2/5 - n4/7
1 - 2/3 + 4/5  - 16/7

1 - 0.67 + 0.8 - 2.28
= 1.80 - 2.95
= -1.15

1
0.33 (1 - 0.67)
-0.47 (1 - 0.67 - 0.8 )
'''
-----------------------------------	
'''
# Find sum of the series:
# n - n2/3 + n4/5 - n8/7 .....
# (1<n<5 and 1<m<10)
'''
n = int(input('Enter the N value: '))
m = int(input('Enter numbers of terms in the series: '))
# check for invalid input data
if (n <= 1 or n >= 5) and (m <= 1 or m >= 10):
    print('Invalid data entered')
    exit('End of Program')

# For valid input data:
sum = 0
for i in range(m):
    sum += (n ** 2 ** i) / (2 * i + 1) * ((-1) ** i)
    print('sum = ', sum, 'i = ', i)

print('Sum of the terms is ', sum)
-----------------------------------
sum = 7 + 5 + 3 + 2 = 17

Read NUM
while digits available in NUM:
    fethch last digit from NUM, say DIGIT
    if check_is_prime(DIGIT):
        sum += DIGIT

if check_is_prime(sum):
    print YES
else:
    print NO  
--------------------------
Read a number from the user and print the Lucky digit of the user where the lucky digit is found by finding the sum of digits of the given number and repeat the algorithm until single digit number is arrived.

789
24
6
---------------------------
'''
Find Nth term of combined series:
1 2 2 3 3 5 5 7 8 11 13 13

Odd Placed Terms: 1 2 3 5 8 13 21

Even Placed Terms: 2 3 5 7 11 13 17

1. The Given series is a combination of 2 series namely Fibo and Prime
2. Odd placed terms are Fibo numbers
3. Even placed terms are Prime numbers
4. When N is Odd, print (N/2 + 1)th Fibo term otherwise N/2th Prime term

Read N
if N is Odd:
    print_fibo_term(n/2 +1)
else:
    print_prime_term(n/2)

i = 2
count = 0
n = 7 (Assumed)
while True:
    if check_if__prime(i):
        count += 1
    if count == n:
        return i # Only exit of the loop
    i += 1
'''
import math

def check_if_prime(n):
    if n == 2:
        return True
    root = math.ceil(math.sqrt(n))
    for i in range(2, root+1):
        if n % i == 0:
            return False
    return True

def find_prime_term(n):
    i = 2
    count = 0
    while True:
        if check_if_prime(i):
            count += 1
        if count == n:
            return i # Only exit of the loop
        i += 1

'''
Algorithm to find Nth Fibo term
Read N

first_num = 1
second_num = 2
if N is 1 return first_num
if N is 2 return second_num
for i in range(3, n+1):
    third_num = first_num + second_num
    first_num = second_num
    second_sum = thrid_num
return thrid_num
'''

def find_fibo_term(n):
    first_num = 1
    second_num = 2
    if n == 1:
        return first_num
    if n == 2:
        return second_num
    for i in range(3, n+1):
        third_num = first_num + second_num
        first_num = second_num
        second_num = third_num
    return third_num

n = int(input('Enter the value of N to print the Nth term of the combined series: '))

if n % 2 == 0:
    print('Term-',n, ' of the series is ', find_prime_term(n/2))
else:
    print('Term-',n, ' of the series is ', find_fibo_term(n//2+1))
-------------------------
1. Check if a number is a Palindrome
2. Find sum of 1st and last digits of a number
3. Print Nth digit of a number (starting from Left)
4. Print Nth digit of a number (starting from Right)
5. Accpet the number of Lines from the user and print the following shapes:
1. Right Angled Triangle
2. Equilateral Triangle
3. Square
4. Empty Square
5. Empty Equilateral Triangle
6. Empty Rhombus
7. Hexagon
8. X shape
9. X shape inside Empty Square

*     *
 *   *
   *
 *   *
*     *

*
**
***
****

523756


523765


print('hello', end='')
-----------------------------------
# Find your lucky digit problem

n = int(input('Enter a number to find your lucky digit: '))

sum = 0
while n > 0:
    remainder_digit = n % 10
    sum += remainder_digit
    n = n // 10
    if n == 0 and sum >= 10:
        n = sum
    

'''
789
i=1
sum=9
n=78

i=2
sum=17
n=7

i=3
sum=24
n=0
when digits in n are exhausted and sum is not a single digit number
n=sum
sum=0

i=4
sum=4
n=2

i=5
sum=6
n=0
'''
------------------------------
Day4 Monday 19-02-2024

Assignment Programs Code

setSpeed (int userSpeed) {
	if(speed > 150)
		object.speed = 150;
	else
		object.speed = userSpeed;

len()
max()
min()	
sum()
del 
sorted(list1)

1.
N
Read N elements of the Array
X : Y
X array has large elements

2.
l1 of N elements
l2 of M elements (M <= N)
P = N - M
Now print the unique elements from P array
--------------------------------
Read N (size of original array)
Read N elements of the original array
Read M (size of the Array transported)
Read M elements of the transported array

sort original array
sort transported array
take an empty array named missing_elements

j = 0
k = 0
for i from 0 to len(original_array):
	if original_array[i] == transported_array[j]:
		increment i
		increment j
	else:
		add original_array[i] to missing_elements[k]
		increment i
		increment k
	if j == len(transported_array) and i != len(original_array):
		copy remaning elements from original_array to missing_elements array
		break the loop

---------------------------------
list1 = [2, 3, 5, 5, 8, 10, 13]

print(list1)

for i in range(len(list1)):
	print(list1[i], end=' ')
	
for element in l1: # For each loop
	print(element, end=' ')
	
print(list1[:])
print(list1[::])
print(list1[:4]) # [2, 3, 5, 5]

print(l1[0:1]) # [2] 
print(l1[:6:2]) # 2 5 8

print(l1[-2:1:-2]) # [10, 5]

print(l1[::-1]) # prints the list in reverse

n = int(input('Enter size of Original array: '))

original_array = []
print(f'Enter {n} elements of the Original Array')
for i in range(n):
	original_array.append(int(input()))

m = int(input('Enter size of transported array: '))

transported_array = list()
print(f'Enter {m} elements of the transported Array')
for i in range(m):
	transported_array.append(int(input()))

original_array.sort()
transported_array.sort()

print(original_array)
print(transported_array)

missing_elements_array = []
j = 0

if m == 0:
	missing_elements_array = original_array
else:
	for i in range(len(original_array)):
		if original_array[i] == transported_array[j]:
			j += 1
		else:
			missing_elements_array.append(original_array[i])
		if j == m and i != n-1:
			missing_elements_array.extend(original_array[i+1:])
			break
		
print('Missing elements are: ', set(missing_elements_array))
-------------------------
split()
t splits the given value on the given delimeter. If no delimiter is given then the default delimeter is space.

college = 'Don Bosco Inst Of Tech'
names = [ element for element in college.split() ]
print(names)

for name in names:
	print(name)

LIST COMPREHENSION:

some_string = '2 45'
list1 = some_string.split()
print(some_string)
print(lis1)
--------------------------
some_string = '2,45,55,3,1,11'

list1 = [int(element) for element in some_string.split(',')]

print(some_string) # '2,45,55,3,1,11'
print(type(list1)) # list
print(type(list1[0])) # int
print(list1) # [2, 45, 55, 3, 1, 11]

name = 'Don Bosco'
print(name)
print(name[-1])
print(name[1:-1])
print(name[2:8:2]) # nBs

original_str = 'donbosco'
rotated_str1 = 'oscodonb'

rotated_str2 = 'ocsodonb'

read original string
read rotated string

temp string = rotated str + rotated str

if temp_str.find(original_str) != -1:
	print is a rotated string
else:
	print is not a rotated string
------------------------------------------
Read a list of email IDs and print the service disctinct provider names

email = input()

index_of_at = email.find('@')
index_of_dot = email.find('.', index_of_@+1)

domain_name = email[index_of_at : index_of_dot]
print(domain_name)
----------------------------------
input_str = 'abcde961'

If the number part in the string is a perfect square, then print the string in reverse else, print the string as it is.
-----------------------------
input_str = racecar2929

If the alphabet part of the string is a Palindrome, then print sum of the squares of the digits in the number part of the string.
Otherwise print sum of the digits of the number part in the string.
--------------------------------------
Look-Up time: Time taken to access one element in the DS.
In an Array, the look-up time is 1 unit.
Thus, the efficiency of look-up in an Array is O(1), read as Big-Oh(1)

EFFICIENCY:
There are 3 types
BCE
ACE
WCE

Properties of Big-Oh:
1. It is usually used to find WCE. However, we can also use it to find the other 2.
**2. B ig-Oh doesn't give the exact efficiency of the Algorithm. Rather it tells us only the Order in which the efficiency is.
e.g: Unit, Linear, quadratic, logarthmic, exponential, factorial, cudic, sqrt etc.
3. It considers the size of the DS (input size) to be 'n'
4. It considers the input size 'n' to be very big
5. It finds the efficiency on the input size 'n'
6. 
-----------------------------------------
Finding an element in a list/array.
Possibilities:
1. element is found
	1. at 1st position
	2. at last position
	3. exactly at middle
	4. else where
2. element is not found
NOTE: If element is present multiple times, then we consider the 1st occurance only.

BCE: O(1)
WCE: O(n)
ACE: O(n)

To find smallest element in an Array: O(n)
Swap consecutive elements of an array: O(n)

BINARY SEARCH:
BCE: O(1)
ACE: O( )
WCE: O(log(n))
2  3  5  7  11  13  17  19  23  29  31  37


Receive: array and search_key
low  = 0
high = n-1

do:
	mid = (low + high) // 2 (integer division)
	check if element at the index mid is search_key
	YES: stop search. return mid as serach_key index
	NO: check if search_key is less than mid_element:
		YES: high = mid - 1
		NO: low = mid + 1
until low <= high	

def binary_search(array, search_key):
	search_key_index = -1 # assume the search element is not found
	while low <= high:
		mid = (low + high) // 2 
		if array[mid] == search_key:
			search_key_index = mid
			break
		elif search_key < array[mid]:
			high = mid -1
		else:
			low = mid + 1
	return search_key_index

Assume number of iterations to be X

X = n  n/2   n/4   n/8  ....... 8   4   2   1
n = 2p(x-1)							2p2 2p1	2p0

n = 2 power X
X = log(n)

SORTING ALGORITHMS:
Bubble sort (Brute Force)
Selection sort (Brute Force)
Insertion (Decrease and conquer)
Quick Sort
Merge Sort

Tree
Binary Tree
BST
BBST
Self Balancing BST
AVL Tree
-----------------------------------
23  11  7  17  29  3  2  19

11  23  7  17  29  3  2  19 (swap 23 with 11)
11  7  23  17  29  3  2  19 (swap 23 with 7)
11  7  17  23  29  3  2  19 (swap 23 with 17)
11  7  17  23  29  3  2  19 (no swap)
11  7  17  23  3  29  2  19 (swap 29 with 3)
11  7  17  23  3  2  29  19 (swap 29 with 2)
11  7  17  23  3  2  19  29 (swap 29 with 19)

7  11  17  3  2  19  23  29
 
2  3  7  11  17  19  23  29


for i from 0 to n-1:
	for j from 0 to n-i-1:
		if array[j] > array[j+1]:
			swap array[j] with array[j+1]
			sorted = False

WCE: O(n square)
ACE: O(n square)
BCE: O(n square)

OPTIMIZATION:
for i from 0 to n-1:
	sorted = True # Assume the array is sorted
	for j from 0 to n-i-1:
		if array[j] > array[j+1]:
			swap array[j] with array[j+1]
			sorted = False
	if sorted:
		break # breaks the outer loop

WCE: O(n square) Quadratic
ACE: O(n square)
BCE: O(n) Linear 

Selection Sort:
23  11  7  17  29  3  2  19

for i from 0 to n-1 do:
	smaller_element_index = i
	smaller_element = array[i]
	for j from i+1 to n-1 do:
		if smaller_element > array[j]:
			smaller_element = array[j]
			smaller_element_index = j
	swap array[smaller_element_index] with array[i]
	
2  11  7  17  29  3  23  19	

-----------------------------------------------------
22  11  7  17  	29  3  	23  19


3	7	11	17	19	22	2	29

3	7	11	17	39
O(n)

for i from 1 to n-1:
	element = array[i]
	j = i-1
	while j >= 0 and element < array[j]:
		array[j+1] = array[j]
		j--
	array[j+1] = element

7  11  22  17  	29  3  	23  19

i=2
e=7
j=1

a[2] = 22
j=-1
array[0]=7

3	7	11	17	19	22	23	29

7	3
11	7	3
17	11	7	3
------------------------
DAY7 THURSDAY 22-02-2024

Stack:
A DS that works on LIFO strategy.
Applications:
1. Re-do Un-do in Text editors
2. Infix expression to Postfix conversion and solving a postfix expression.
3. DFS Algorithm uses Stack
4. Call Stack (How functions are executed implicitly)

SPECIAL PURPOSE REGISTERS:
SP: stack pointer: It points to the top frame in the stack
FP: frame pointer: It points to the frame of the function that is currently running.
IR: instruction register: It holds the address of the instruction that is currently running.
PC: program counter: It holds address of the next instruction to be executed.

Assignment:
Accept a string of Pairs of Peranthesis and check if they are arranged properly. If so, print the number of pairs of peranthesis else print improper arrangement.

((()())) : 4 pairs
(()))	 : improper arrangement
-------------------------------------
BAD WAY OF IMPLEMENTING QUEUE IN PYTHON (similar to C code)

#Program to implement Stack using List DS

import sys
class Queue:
        def __init__(self, size = 5):
                self.queue = [] #create an empty list to impliment the Stack
                self.fp = -1 
                self.rp = -1
                self.size = size
                print("An empty Queue of size ", size, " is created")

        def en_queue(self):
                if self.rp == self.size-1:
                        print("Queue is full")
                        return
                self.rp += 1
                self.queue.insert(self.rp, input("Enter data to be inserted: "))

        def de_queue(self):
                if self.fp == self.rp:
                        print("Queue is empty")
                        return
                self.fp += 1
                print("Deleted element is ", self.queue[self.fp])
                #self.queue.pop(self.fp)
                if self.fp == self.rp:
                        self.fp = self.rp = -1

        def display_Q(self):
                if self.fp == self.rp:
                        print("Queue is empty")
                        return
                print("Queue elements are: ", self.queue[self.fp+1:self.rp+1])

def invalid_choice():
        print("Invalid choie entered")

que = Queue(4)
stk_oprs = {
        1 : que.en_queue,
        2 : que.de_queue,
        3 : que.display_Q,
        4 : sys.exit
}
choice = 0
while True:
        print("\n1:Insert 2:Delete 3:Display 4:Exit")
        choice = int(input("Enter your choice: "))
        stk_oprs.get(choice, invalid_choice)()
----------------------------
GOOD WAY OF IMEPLENTING A QUEUE OF CERTAIN CAPACITY:

#Program to implement Stack using List DS

import sys
class Queue:
        def __init__(self, capacity = 5):
                self.queue = [] #create an empty Q
                self.capacity = capacity
                print("An empty Queue is created")

        def en_queue(self):
                if len(self.queue) == self.capacity:
                        print("Queue is full")
                        return
                self.queue.append(input("Enter the element to be inserted: "))

        def de_queue(self):
                if len(self.queue) == 0:
                        print("Queue is empty")
                        return
                print("Deleted element is ", self.queue[0])
                del self.queue[0] # self.queue.pop(0)

        def display_Q(self):
                if len(self.queue) == 0:
                        print("Queue is empty")
                        return
                print("Queue elements are: ", self.queue[:])

def invalid_choice():
        print("Invalid choie entered")

que = Queue(4)
stk_oprs = {
        1 : que.en_queue,
        2 : que.de_queue,
        3 : que.display_Q,
        4 : sys.exit
}
choice = 0
while True:
        print("\n1:Insert 2:Delete 3:Display 4:Exit")
        choice = int(input("Enter your choice: "))
        stk_oprs.get(choice, invalid_choice)()
---------------------------
ALGORITHM:
Read a string of paranthesis say input_str
open_count = cloce_count = 0
arrangement = True
for each element in input_str do:
	check if element is not '(' and not ')':
		print invalid input
		exit(0)
	check if element is '(':
	YES: open_count += 1
	NO: cloce_count += 1
	if cloce_count > open_count:
		print invalid arrangement
		arrangement = False
		break
if arrangement and open_count == cloce_count:
	print 'Number of pairs of paranthesis is', open_count
-------------------
A1.
{(})}
{(})
{(){(())}()}

A2.

[{()[((){})}]

A3.
Karpekar's constant
Count the number of times the logic was implemented

A4.
Find the next bigger possible number from the given number. All the digits in the input number must be there in the o/p number.

A5.
Convert infix expression to postfix (Do not use paranthesis) Level1

A6.
Convert infix expression to postfix (use paranthesis) Level2

A7.
Evaluate Postfix expression
---------------------------------
DAY8 23-02-2024 Friday

n = int(input('Enter number of requests: '))

requests = []
sum = 0

print(f'Enter the {n} memory allocation or deallocation requests: ')
for i in range(n):
	requests.append(int(input()))
	
for i in range(n):
	if i % 2 == 0:
		sum += requests[i]
		
if sum < 0:
	print('Total memory deAllocated by server 1 is ', math.absolute(sum), ' uints of memory')
else:
		print('Total memory allocated by server 1 is ', sum, ' uints of memory')
-------------------------
Read N

shoe_prices = []
Read P
Read N shoe_prices

shoe_prices.sort()
count = 0
sum = 0
for i in range(n):
	if count <= P and shoe_prices[i] < 0:
		sum += math.absolute(shoe_prices[i])
	count += 1

The maximum amount the daughter and mother can earn is {sum}
----------------------------
def check_arrangement(boy_heigts, girl_heigts):
	for i in range(1, len(boy_heigts)):
		if boy_heigts[i] < girl_heigts[i-1] or girl_heigts[i] < boy_heigts[i-1]:
			return 'No'
	return 'Yes'


Read T (Number of test cases)

arrangement = []
for i in range(T):
	Read N (bumber of boys or girls)
	Read N boys heights boy_heigts[]
	Read N girls heights girl_heigts[]
	
	sort boy_heigts
	sort girl_heigts
	
	arrangement.append( check_arrangement(boy_heigts, girl_heigts) )

print arrangement
------------------------------------------
DAY9 SATURDAY 24-02-2024

def check_arrangement(boy_heigts, girl_heigts):
	arrangement_possible = True
	for i in range(1, len(boy_heigts)):
		if boy_heigts[i] < girl_heigts[i-1] or girl_heigts[i] < boy_heigts[i-1]:
			arrangement_possible = False
			break
	if arrangement_possible and ( (boy_heights[-1] > girl_heights[-2] and boy_heights[-1] > girl_heights[-1] ) or (girl_heights[-1] > boy_heights[-2] and girl_heights[-1] > boy_heights[-1] ) ):
		arrangement_possible = False
	if arrangement_possible:
		return 'Yes'
	return 'No'

T = int(input('Enter number of test cases: '))

arrangement = [] #stores yes/no 
n = 0
boy_heights = []
girl_heights = list()

for i in range(T):
	n = int(input('Enter number of boys/girls: '))
	print(f'Enter the heights of {n} boys')
	for i in range(n):
		boy_heights.append(int(input()))

	print(f'Enter the heights of {n} girls')
	for i in range(n):
		girl_heights.append(int(input()))
		
	boy_heights.sort()
	girl_heights.sort()
		
	arrangement.append( check_arrangement(boy_heights, girl_heights) )

print(arrangement)
------------------------------------
TREES:
-> A Tree is an acyclic data structure.
-> A Tree starts with a ROOT (The only starting point of the DS)
-> Data in the Tree are stored in NODES
-> Every Node can have Child nodes
-> The Node we can reach from the Root to an immediate node is called as Child Node.
-> The Node from which we TRAVERSE to the child node is called as Paremt Node.
-> The Root of the Tree is considered to be at Level-1 and its immediate child node at Level2 and so on.
-> A Node with no chil no child nodes (Zero child Nodes) is called as LEAF NODE (Brahmachi Node)
-> A Tree in which there can be a maximum of 2 child nodes to every node is called as BINARY TREE.
-> When we move from the Root node to its child node, we call it as TRAVERSING. Thus with one traversal, we move to next level in the Tree.
-> The maximum possible level (Longest path) in the Tree is called as DEPTH/HEIGHT of the Tree.
-> In a Binary Tree of Depth/Height of 'n', we can have a maximum of (2 power n)-1 Nodes (Odd number)
-> The Child Node we reach from the Root, itself can be treated as the Root and along with its descendents itself as an independent or new Binary Tree.
-> The Left Child of the Root along with the descendents of the Left child is called as LEFT SUB TREE and thus we also have RIGHT SUB TREE.
-> Note that, a Binary Tree with all the nodes having either only Left child nodes or Only Right child nodes is actually a Linear DS.
-> There are 3 ways of Traversing a Binary Tree. With these 3 traversals we can reach to every node in the Tree only once.
InOrder Traversal: LrootR
PreOrder Traversal: rootLR
PostOrder Traversal: LRroot
Note that, Left always comes before the Right. What changes is the position of the root.
IMPORTANT:
	While traversing a Binary Tree, when ever we reach a new node (child node), it itself must be treated as a new tree that is formed with its descendents. Thus, what we algorithm apply to the actual/whole Binary Tree, is applied to the Tree at every new level with every node that is traversed.
-> If in a Binary Tree (BT), the data is ARRANGED in such a way that the Left child node is less than the Root node data and the Right child node data is greater than or equal to the root node data and this is applicable for the entire tree (recursively with every node at every level), then such a BT is called as 	BINARY SEARCH TREE (BST)
-> Note that, when we construct just a BT, we fill the Tree with nodes at the current level and we go next level only when all possible positions in the current level are filled.
-> However, adding/inserting a node into a BST depends on comparing the data in the nodes of the BST and we move left or right depending on the data.
-> Suppose we have a BT of Height 'n' and it has (2 power n)-1 nodes, that is maximum possible number of nodes, then such a tree is called as COOMPLETE BINARY TREE.
-> Suppose if every node in the BT has exactly Zero or 2 child nodes, then such a BT is called as STRICTLY BINARY TREE.
-> Suppose if we have exactly (2 power n)-1 nodes in a BST of depth 'n', then the efficiency (WCE) of searching a node in it will be O(log(n)). Note that, the best case scenario is when the search node is the root node of the complete Tree, and thus the efficiency would be O(1)
-> Note that if the BT has exactly or nearly (2 power n)-1 nodes, then such a BT is called as Almost BALANCED BT.
-> If a BT is complete BT, then is also called as FULLY BALANCED BT.
-> A worst possible BT is when it is least possible nodes for a given height say 'n', which is actually a Linear DS. Precisely in such a BT, we have exactly one node at every level.
-> Thus in a BBST, the LookUp of a node is O(logn) which is the fastest algorithm.
-> PATH in a BT: Starting from the Root, the traversal to reach upto disctinct Leaf nodes is called as Paths of the Tree.
	It is very important to note that to reach to any Node in a Tree there is always only one Path.
-> The maximum depth of a path in the Tree is height of the tree.
APPLICATIONS OF BINARY TREE AND BST:
1. It is mainly used when arrangement of data is to be done and the operations (CRUD) to have the best possible efficiency, say log(n).
2. To get the data in Order, we can make use of BST and traverse the Tree in InOrder.
3. 
-------------------
RECURSION:
A function that calls itself. In other words, when the Caller (calling function) and the Callee (called function) are one at the same.

Assignment: (Draw BST for the below given data)
49  23  15  28  5  15  75  55 50  60  90  85  90

Problem on Trees:
1. With the given data (list of numbers), build the BST using:
	1. Iteratively
	2. Recursively
2. Do the 3 differet traversals to print all the nodes of the BT:
	1. Ore Order
	2. In Order (To print the BST data in Ascending Order)
	3. Post Order
3. Accept any 2 traversals of the BT (InOrder must be one of the 2) and create the BT
	1. InOrder and PreOrder
	2. InOrder and PostOrder
4. Deleting a Node from a BST:
	When the node to be deleted has:
		1. Zero Children
		2. One Child
		3. 2 Children
5. Search for an element in a BST

Important Note:
All the operations on BST such as Insert new node, Search a specific node, update a specific node, delete a node has Big-Oh of LogN efficiency (worst case)
BCE of any of the operations mentioned above is O(1)

1. What is the efficiency (WCE) of adding a new node into a BST ?
2. While adding a new node into the BST, When will it be O(1) efficiency ?
3. What is the efficiency of accessing all nodes of a BST using PostOrder traversal ? O(n) Linear.
4. What is the efficiency of accessing the leaf node in a BST having maximum possible Height/Depth and least possible number of nodes ?
5. What is the efficiency of accessing any leaf node in a Complete BST?
6. What is the efficiency of accessing nodes in only one Path of the BT ? O(LogN)
NOTE: Accessing One Path of the BT is LogN efficiency. Thus accessing all the paths has an efficiency of O(N).
Thus LogN + LogN ... N times is N itself.

DELETING A NODE FROM A BST:
When the node to be deleted has:
1. Zero Children: (i.e., we are deleting a leaf node)
	Go to the Respective link of the Node being deleted and make it Null.
2. One Child:
	The only child of the node to be deleted, will take its onw place. i.e., go to the parent node of the node being deleted, and make the only child of the node being deleted, the child of its parent. (Grand child becomes child). In other words, The child of the node being deleted takes the place of its parent.
3. 2 Children:
	 Cut the Left Sub Tree of the node being deleted (All the descendents starting from its left child) and attach it to the Left-Most child of it's Right child (Right child of the node being deleted.) And the Right child of the node being deleted becomes the Right child of the Parent of the Node being deleted. i.e., the Right Child takes the place of its parent node which is the node being deleted.
	 NOTE: When ever we delete a node with 2 children, the Tree gets imbalanced, i.e., the height of the Modified Tree increases.
	 NOTE: Thus there must be an Algorithm to Balance a BST.
	
PROGRAMS TO LEARN RECURSION.
Important Note: If we can solve a problem easily using a loop, it is Foolishness to use Recursion (recursive function)
The following programs are only to illustrate the use and working of Recursive function. 
	
1. Find sum of Array elements.
2. Find Factorial of a number.

def find_factorial(num):
    if num == 1 or num == 0:
         return 1
    return num * find_factorial(num-1)

input_num = int(input('Enter a number to find it\'s Factorial: '))
factorial = find_factorial(input_num)
print(f'Factorial of {input_num} is {factorial}')
---------------------------
Program to create a BST:
Note: Every new node is always added as a leaf node.

Algorithm:
Create a Node
Now Insert it into the BST:
	If the BST is empty:
		Insert it as the Root and return
	Check if the new_node data is less than root data
		traverse to the left node
	else
		traverse to the right node
	Once the node to which the new_node has to be attcahed as its child node, we exit the loop
	Now check if the new_node has to be attached as left child or right child.
	
# global root = None

class Node:
    def __init__(self):
        self.data = int(input('Enter data of the new node: '))
        self.left = None
        self.right = None

def add_node(root):
    new_node = Node() # create a new node
    if root == None: # if BST is empty
        return new_node # make the new node as the root of the BST
    temp1 = root # temp1 points to current node
    temp2 = None # temp2 points to paremts of temp1
    # Thus temp2 follows temp1
    while temp1 != None:
        temp2 = temp1
        if temp1.data > new_node.data:
            temp1 = temp1.left # traverse to the left child
        else:
            temp1 = temp1.right # traverse to the right child
    # after coming out of the loop
    if temp2.data > new_node.data:
        temp2.left = new_node
    else:
        temp2.right = new_node
    return root


def pre_order_traversal(root):
	if root != None:
        print(root.data, end='  ')
        pre_order_traversal(root.left)
        pre_order_traversal(root.right)
    return root
        
def in_order_traversal(root):
	if root != None:
        in_order_traversal(root.left)
        print(root.data, end='  ')
		in_order_traversal(root.right)
    return root
        
def post_order_traversal(root):
	if root != None:
        post_order_traversal(root.left)
		post_order_traversal(root.right)
        print(root.data, end='  ')
    return root

def invalid_choice(root):
    print('Invalid choice entered')
    return root

def exit_program(root):
    exit('End of Program')

operations = {
     1 : add_node,
     2 : pre_order_traversal,
     3 : in_order_traversal,
     4 : post_order_traversal,
     5 : exit_program
}

root = None
   
choice = 0
while True:
    print('1:AddNode 2:PreOrder 3:InOrder 4:PostOrder 5:Exit')
    choice = int(input('Enter your choice: '))
    if choice >= 2 and choice <= 4 and root == None:
        if root == None:
            print('Tree is empty')
            continue
    root = operations.get(choice, invalid_choice)(root)
-----------------------------------------------
# global root = None

class Node:
    def __init__(self):
        self.data = 0
        self.left = None
        self.right = None

def add_node1(root): # Iterative
    new_node = Node() # create a new node
    if root == None: # if BST is empty
        root = new_node # make the new node as root of the BST
        return root 
    temp1 = root # temp1 points to current node
    temp2 = None # temp2 points to paremts of temp1
    # Thus temp2 follows temp1
    while temp1 != None:
        temp2 = temp1
        if temp1.data > new_node.data:
            temp1 = temp1.left # traverse to the left child
        else:
            temp1 = temp1.right # traverse to the right child
    # after coming out of the loop
    if temp2.data > new_node.data:
        temp2.left = new_node
    else:
        temp2.right = new_node
    return root

def add_node2(root, data): # Recursive
    if root == None:
        root = Node() # create a new node
        root.data = data
        return root
    if root.data > data:
        root.left  = add_node2(root.left, data)
    else:
        root.right = add_node2(root.right, data)
    return root

def pre_order_traversal(root):
    if root != None:
        print(root.data, end='  ')
        pre_order_traversal(root.left)
        pre_order_traversal(root.right)
    return root
        
def in_order_traversal(root):
    if root != None:
        in_order_traversal(root.left)
        print(root.data, end='  ')
        in_order_traversal(root.right)
    return root
        
def post_order_traversal(root):
    if root != None:
        post_order_traversal(root.left)
        post_order_traversal(root.right)
        print(root.data, end='  ')
    return root

def invalid_choice(root):
    print('Invalid choice entered')
    return root

def exit_program(root):
    exit('End of Program')

operations = {
     1 : add_node2,
     2 : pre_order_traversal,
     3 : in_order_traversal,
     4 : post_order_traversal,
     5 : exit_program
}

root = None # at the beginning the Tree is empty  
choice = 0
while True:
    print('\n1:AddNode 2:PreOrder 3:InOrder 4:PostOrder 5:Exit')
    choice = int(input('Enter your choice: '))
    if choice == 1:
        data = int(input('Enter data of the new node: '))
        root = add_node2(root, data)
        continue
    
    if choice >= 2 and choice <= 4 and root == None:
            print('Tree is empty')
            continue
    root = operations.get(choice, invalid_choice)(root)
---------------------------------------------
Quick Sort

Partition:
Consider some element in the Array as reference element (PIVOT) element.
Now compare the elements in the array (unsorted)

13     20     25     35     36     41     40     50     40    

i will access all indices of the Array (i will increment in every iteration)
k will increment only if we get a smaller element than Pivot and also we will swap the elements in indices i and k.
i = 7
swap a[i] with a[k]
k = 3
By doing so, we are moving the larger elements (than the pivot) to the right
and also we are marking the index of pivot (which is K)


def partition(numbers, low, high):
    k = low # index of 1st element in the un sorted array
    pivot = numbers[high] # last element in the array
    for i in range(low, high):
        if numbers[i] < pivot:
            numbers[i], numbers[k] = numbers[k], numbers[i]
            k += 1
    numbers[k], numbers[high] = numbers[high], numbers[k]
    return k

def quick_sort(numbers, low, high):
     if low < high: # base/exit condition
        pivot_index = partition(numbers, low, high) # partition the Array
        quick_sort(numbers, low, pivot_index-1)#quick sort the left partitioned array
        quick_sort(numbers, pivot_index+1, high)# quick sort the right partitioned array

n = int(input('Enter size of the Array: '))

numbers = []
print(f'Enter {n} numbers of the Array')
for i in range(n):
    numbers.append(int(input()))

print('The Input Array is:\n', numbers)

quick_sort(numbers, 0, len(numbers)-1)
print('The Sorted Array is:\n', numbers)
------------------------
MERGE SORT: (Stable sorting algorithm)
12  1  90  45  88  33  22  44  11

12  1  90  45      88  33  22  44  11
12  1      90  45      88  33      22  44  11
12     1      90     45      88     33      22     44  11
12     1      90     45      88     33      22     44     11
1  12      45  90      33  88      22  44      11
1  12  45  90       22  33  44  88       11
1  12  22  33  44  45  88  90      11
i=3                         j=1
1  11  12  22  33  44  45  88  90
k=3

Divide Step  logN (Logarthemic)
Conquer Step N  (Linear)

Merge sort works same way in all cases.
Thus the Best and Worst case efficiencies is same
i.e. O(N*LogN)

Coming to Quick Sort:
BCE: O(N*LogN)
This is when the Pivot element Partitions the array into 2 Equal Halves.
WCE: O(N square) Quadratic
1 2 3 4 5 6 7 8 9

def divide_array(numbers, low, high):
	if low < high:
		mid = (low + high) // 2
		merge_sort(numbers, low, mid-1)
		merge_sort(numbers, mid, high)
	# merge_arrays()
	
------------------------
n = 10
for i in range(n): # i = 0, 1, 2, ..... 9
    i += 1
    print('i = ' + str(i))
    
'''
i = 0
i = 1
i = 2
i = 3

def range(n):
    # INSTR1
    # INSTR2
    return k
'''
a = {5,6,7}
a.add(5)
print(a)

dictionary = {5:'blr', 6:'mys', 7:'mlr'}
print(dictionary)
dictionary[5] = 'hbl'
print(dictionary)
--------------------------
# What snippet would you insert in the line indicated below:
n = 0
while n < 4:
	n += 1 
	# insert your code here
	print(n, end=' ')

# To print the following string to the monitor after the loop finishes itsexecution:1 2 3 4
----------------------------------
EXCEPTION HANDLING:

What is an Exception?
An exception is a Runtime error. Nothing but the error which is not a syntax error.

When ever a runtime error occurs (of course at runtime), it must handled by the code (wirtten by the programmer).
If it is not handled, then it is handled by the Interpreter (Python runtime machine).
How does it do?
It simply stops the execution of the program and renders the error(exception).

Stoping the execution and displaying the Technical error is very very disturbing and creates enxity in the mind of the user.
The worst part of an exception is that it stops the execution of the program.

Hence, we must handle the exceptions and give a proper solution to the exception.
The good thing about exception handling is that we can continue to execute the program. However what we cannot do is, successful execution of that part of the code (function/method) where the exception is created.

For example, if a function is reading the student data, and in the place of phone number, the user mistakenly has given alphanumeric data, then it cannot be converted to int data. Hence value error.

Now, if we implement exception handling, we can make the complete O/P of the code understandble by the user.
Otherwise, the user would end up seeing technical errors which is not understandble by the user. Also, the execution stops abtruptly.

HOW TO IMPLEMENT EXCEPTION HANDLING:

The code where we suspect the exception may occur, is put into "try block".
As suspected, if the error occurs, then we must have provided "except block" where the solution for the exception is given.

Note: If the exception doesn't create, then all of the code in try block is executed and the except block is skipped and the code defined after the except block continues to execute

RULES TO WRITE TRY-EXCEPT BLOCKS:
1. For every try block there must be an except block. And there cannot be any code defined in between them (i.e., both these blocks must come one next to each other).
2. For each try block we can define one or more except blocks.
3. We can define a try block inside an except block. So in this case we SUSPECT an error to occur while giving solution to the created error.
4. We can define a block that is defined after all the except blocks named FINALLY. It is optional to define a finally block. But if it is defined, then it is always executed, whether or not the exception is created. For example, we must close the file or database whether the successful operation is completed or not.
5. There can be only one finally block per try block.
*6. An except block which doesn't mention any error is said to be generic except block and it must be written at the last when ever we write multiple except blocks for a try block. In other words, the specialized except blocks must appear before the generalised (catch all) except block.

class DigitError(BaseException):
    def __init__(self, message):
        self.message = message

try:
    ph_num = int(input('Enter your Phone number: '))
    if len(ph_num) != 10:
        raise DigitError(msg = 'Number of digits entered is' + str(len(ph_num)))
    print('Your Phone number is ', ph_num)
except ValueError: # Specialized except block
    print('You mostly entered Alphanumeric data')
except DigitError():
    print('You did not enter 10 digit number')
except: # Generalised (catch all) except block
    print('You did not enter a valid Phone number')
print('Thank you for using our services')

KEYWORDS IN EXCEPTION HANDLING:
1. try: to add the code where we suspect the error may occur
2. except: To speficy the solution for the exception created. Note that except block with out the error type mention is a generic or catch all except block.
3. except X: here X is the type of the error (built in  or user defined)
4. raise: It is used to explicitly raise(create) an error/exception
5. finally: The optional block which is always executed
throws: It is used to propogate the exception back to the caller. That is, if we the (Called Function) do not wish to handle the exception, then we can pass it to our Caller (calling function). In such a case it becomes necessary to the caller to handle the exception or propagate it to its Caller.

Syntax for defining try-except-finally blocks:

def some_function_or_method():
	try:
		TRY BLOCK
	except1:
		EXCEPT1 BLOCK
			try:
				TRY BLOCK
			except:
				NESTED EXCEPT BLOCK
	except2:
		EXCEPT2 BLOCK
	finally:
		FINALLY BLOCK
	OTHER INSTRUCTIONS MAY GO HERE

Note: The line in the try block where the exception occured, the remaining lines of the try block doesn't execute.

That is, the normal flow of execution (i.e., the current busniess logic or current action cannot be done successfully) cannot continue, rather it is skipped and the solution for the error is done and then the flow comes back into normal flow of execution.

Thus note that when an exception occurs, the control goes out of normal flow of execution, gives solution to the exception and returns back into the normal flow of execution.
All these happens from within a function/method.
---------------------------------------
Numpy
import numpy as np

Numpy Arrays:

arr1 = np.zeros((1, 3)) # Created an Array of 1D (i.e. a single array) of 3 elements, all of which are zeroes. The Array created is nothing but a Python List.
print(arr1)

arr1 = np.zeros((3, 5)) # 3 rows each of 5 elements and all 15 elements will be zeros.
print(arr1)
---------------------------------------------
import numpy as np

To initialize an Array/List of multi dimentional, with all elements Zero:

arr1 = np.zeros((3, 5))
print(arr1)

print(arr1[2][0]) # 3rd row 1st element
print(type(arr1[2][0])) #numpy.float64 is nothing but double in C/C++/Java
----------------------------
To initialize an Array with a number other than Zero:
Method is full()

import numpy as np
array2 = np.full((1, 5), 15) # Creates a List with a single List. Thus, array2 here, though has single List, it is 2D list.
print(array2)

print(array2[0]) # Prints the 1st list in the 2D list array2
print(array2[0][1]) # Prints the 2nd element in the 1st list of array2
print(array2[1][0]) # Error. There is no 2nd list in array2
-------------------------------------------
import numpy as np
array2 = np.full((3, 2), 5) 
print(array2)
print(array2[2][2]) # Error there is no 3rd element in the 3rd row
print(array2[2][1]) # 5
---------------------------------------
To Create numpy array/list with a range of values:
Method is arange()
It takes 2 arguments or 3 arguments
arange(1, 10) # The range is from 1 to 9. Note that the 2nd Arg is excluded.
arange(1, 20, 3) # The 3rd Arg depicts the increment for every element in the List

Note: arange() create a 1D List and not 2D list

arr3 = numpy.arange(1, 10)
arr4 = numpy.arange(1, 20, 4)
------------------------------
np.array([[1,2],[3,4]])
OUT:
array([[1, 2], [3, 4]])
-----------------------------------------
np.zeros((3,1))
OUT:
array([[0.],
       [0.],
       [0.]])
---------------------------------------
You can also initialize an array with ones instead of zeros:

np.ones((3, 1))
OUT:
array([[1.],
       [1.],
       [1.]])
--------------------------------------
np.full() creates an array repeating a fixed value (defaults to zero). Here we create a 2x3 array with the number 7 in each element:

np.full((2,3),7)
OUT:
array([[7, 7, 7],
       [7, 7, 7]])
--------------------------------------
Array shape
All arrays have a shape accessible using .shape
For example, let's get the shape of a vector, matrix, and tensor.

vector = np.arange(5)
print('Vector:', vector)
print("Vector shape:", vector.shape)

matrix = np.ones([3, 2])
print("Matrix:", matrix
print("Matrix shape:", matrix.shape)

tensor = np.zeros([2, 3, 3])
print("Tensor:', tensor)
print("Tensor shape:", tensor.shape)

print(tensor[0][1][1]) #Prints the 1st Matrix's 2nd Row, 2nd element
----------------------------------------
arr = np.arange(1, 10)
print(arr, '\n')

# Reshape to 3x3 matrix
arr = arr.reshape(3, 3)
print(arr, '\n')

# Reshape back to the original size
arr = arr.reshape(9)
print(arr)
----------------------------------------
import numpy as np

arr1 = np.arange(12)

arr2 = arr1.reshape(2, 6)
arr3 = arr1.reshape(6, 2)
arr4 = arr1.reshape(3, 4)
arr5 = arr1.reshape(12, 1)

print('Arr1:\n', arr1)
print('Arr2:\n', arr2)
print('Arr3:\n', arr3)
print('Arr4:\n', arr4)
print('Arr5:\n', arr5)
---------------------------------------------------
Numpy can try to infer one of the dimensions if you use -1. You will still need to have precisely the correct number of digits for the inference to work.

arr = np.arange(1, 10).reshape(3, -1)
print(arr)
--------------------------------------------
import numpy as np

arr1 = np.arange(1, 10)
arr2 = np.arange(2, 25, 2)

arr3 = arr1.reshape(3, -1)
arr4 = arr2.reshape(4, -1)
arr5 = arr2.reshape(2, -1)
arr6 = arr2.reshape(3, -1)

arr7 = arr2.reshape(-1, 4) # Numpy predicts and fixes the number of rows

print('Arr1:\n', arr1)
print('Arr2:\n', arr2)
print('Arr3:\n', arr3)
print('Arr4:\n', arr4)
print('Arr5:\n', arr5)
print('Arr6:\n', arr6)
print('Arr6:\n', arr7)
-----------------------------------------
inputNum = int(input("Enter a number to find sum of its digits: "))

temp = inputNum
sumOfDigits = 0

while temp != 0:
	remainderDigit = temp % 10
	sumOfDigits = sumOfDigits + remainderDigit
	temp = temp // 10 #integer division is important

print(f'Sum of the digits of {inputNum} is {sumOfDigits}')
--------------------------------------------
In Python, passing the primitive values is always done using CALL BY VALUE
def func(num):
	print("num from func before changing its value = ", num)
	num = 50
	print("num from func after changing its value = ", num)

#Note, once the func() ends, the local variable 'num' is deleted. And it is also accessible only inside func()

num = 5
print("num from main before changing its value = ", num)
func(num) # Call by value (We are passing a COPY of num to the function func() )
print("num from main after function call = ", num)
# Here we observe that the modified value in CALLED FUNCTION is not updated in calling function
num = 25
print("num from main after changing its value = ", num)
----------------------------------------------------------------
def func(list1): # We have received the reference value of the list object
	print("num from func before changing its value = ", list1)
	list1.remove(1.1)
	print("num from func after changing its value = ", list1)

numbers = [2.5, 3.3, 5.5, 1.1]
print("List from main before changing its value = ", numbers)
func(numbers) # Call by Reference (We are passing the reference value of the List Object and not the object itself)
print("List from main after function call = ", numbers)
numbers.insert(3, 30.3)
print("List from main after changing its value = ", numbers)
---------------------------------------
fo = open("D:\\Python Programs\\practice\\textfile1.txt", "r")
#opening a file in read mode
print ("Name of the file: ", fo.name)#printing the printing file 
print ("File Closed ? : ", fo.closed) #returns truth value
print ("Opening mode : ", fo.mode) # file opening mode
fo.close() # saves the file on the disk
print ("File Closed? : ", fo.closed)
----------------------------------------------------
import pickle

class Student:

	def __init__(self):
		self.name = ""
		self.marks = 0
		self.sem = 0
		self.branch = ""

	def __init__(self, name, marks, sem, branch):
		self.name = name
		self.marks = marks
		self.sem = sem
		self.branch = branch

stud1 = Student('Raam', 95, 7, 'ECE')

fo = open("file1.pkl", "ab")
pickle.dump(stud1, fo, pickle.HIGHEST_PROTOCOL)
print("Writing to the file Over")
fo.close()

print("Reading Object from the file:")
with open('file1.pkl', 'rb') as inputFilePtr:
	stud1 = pickle.load(inputFilePtr)
	print('Student Name:  ' + stud1.name)
	print('Student Marks: ' + str(stud1.marks))
	print('Student Sem:   ' + str(stud1.sem))
	print('Student Branch:' + stud1.branch)
----------------------------------------------------
import sys

class Stack:

	def __init__(self, size):
		self.sp = -1
		self.stk = []
		self.stackSize = size
		print(f'An empty Stack of size {self.stackSize} is created')

	def push(self):
		if self.sp == self.stackSize-1:
			print('Stack Overflow')
			return
		print('Enter the element to be pushed: ', end='')
		self.stk.append(input())
		self.sp += 1

	def pop(self):
		if self.sp == -1:
			print('Stack Underflow')
			return
		print(f'Popped element is {self.stk[-1]}')
		del self.stk[-1]
		self.sp -= 1

	def display(self):
		if self.sp == -1:
			print('Stack is empty')
			return
		print('Stack elements are: ', end='')
		tempStk = self.stk[::-1]
		for element in tempStk:
			print(element, end='  ')

def exitProgram():
	sys.exit("System Exiting")

def printError():
	print('Invalid choice entered')

def stackDemo():
	stkSize = int(input('Enter size of the Stack: '))
	stkObj = Stack(stkSize)
	menu = {
		1 : stkObj.push,
		2 : stkObj.pop,
		3 : stkObj.display,
		4 : exitProgram
	}
	while True:
		print('\n1:Push 2:Pop 3:Display 4:Exit,  Your Choice? ', end='')
		choice = int(input())
		menu.get(choice, printError)()

stackDemo()
----------------------------------------------------
class BankAccount:

	def __init__(self):
		self.accNum = 0
		self.accHolderName = ''
		self.balance = 0.0
		self.accType = ''
		print(f'Your account is created.\nEnter your Details now.')
	
	def createAccount(self):
		self.accHolderName = input('Enter your name: ')
		self.balance = float(input('Enter your initial balance: '))
		self.accType = input('Choose type of Account you wish\n(Student, Employee, Business)')
		print(f'Congratulations {self.accHolderName}, Your Acc-Num is {self.accNum}')

	def deleteAccount(self):
		print(f'Your balance amount of Rs.{self.balance} is returned to you via Cheque')
		print(f'Dear {self.accHolderName}, your account is deleted')
		self.accNum = -1  #mean to say Account is deleted

	def displayAccountDetails(self):
		print('Your Account details are: ')
		print(f'Name:{self.accHolderName}, Balance:{self.balance}, AccountType:{self.accType}')

class AccountDemo:

	def __init__(self):
		self.accounts = [] #To store the BankAccount objects

	def exitProgram(self):
		sys.exit("System Exiting")

class AccountDemo:

	def createMenu(self):
		menu = {
			1 : self.createAccount,
			2 : self.deleteAccount,
			3 : self.displayAccount
		}
		return menu

	def __init__(self):
		self.accounts = [] #To store the BankAccount objects
		self.accountNum = 1000 #The starting account number

	def invalidChoice(self):
		print('Invalid Choice enetered')

	def createAccount(self):
		acc = BankAccount()
		self.accountNum += 1
		acc.accNum = self.accountNum #set the AccNum for the new Account created
		acc.createAccount()
		self.accounts.append(acc)

	def deleteAccount(self):
		if len(self.accounts) == 0:
			print('There are no Accounts created yet')
			return
		accNum = int(input('Enter Account number to delete the account: '))
		j = -1
		for i in range(len(self.accounts)):
			if self.accounts[i].accNum == accNum:
				self.accounts[i].deleteAccount()
				j = i
				break
		if j != -1:
			del self.accounts[j]
		else:
			print(f'Account with Acc-Number:{accNum} not found')

	def displayAccount(self):
		if len(self.accounts) == 0:
			print('There are no Accounts created yet')
			return
		accNum = int(input('Enter Acc-Number to print details: '))
		accountFound = False
		for account in self.accounts:
			if account.accNum == accNum:
				account.displayAccountDetails()
				accountFound = True
				break
		if not accountFound:
			print(f'Account with Acc-Number:{accNum} not found')

	def runMenu(self):
		menu = self.createMenu()
		while True:
			print('1:CreateAccount 2:DeleteAccount 3:DisplayAccount 4:Exit')
			choice = int(input('Your choice please: '))
			if choice == 4:
				return
			else:
				menu.get(choice, self.invalidChoice)()

print('Welcome to SBI Online Banking')
userObject = AccountDemo()
userObject.runMenu()
print('Thank you for using our services')
---------------------------------------------------------
# pickling.py
import pickle

class example_class:
    a_number = 35
    a_string = "hey"
    a_list = [1, 2, 3]
    a_dict = {"first": "a", "second": 2, "third": [1, 2, 3]}
    a_tuple = (22, 23)

my_object = example_class()

my_pickled_object = pickle.dumps(my_object)  # Pickling the object
print(f"This is my pickled object:\n{my_pickled_object}\n")

my_object.a_dict = None

my_unpickled_object = pickle.loads(my_pickled_object)  # Unpickling the object
print(
    f"This is a_dict of the unpickled object:\n{my_unpickled_object.a_dict}\n")
----------------------------------------------------------------
>>> square = lambda x : x * x
>>> a = square(35)
>>> import math
>>> b = math.sqrt(484)
>>> import dill
>>> dill.dump_session('test.pkl')
>>> exit()
------------------------------------------------------------------------
The zeros() method creates a list of lists of given dimension, and all the lists will have all its elements Zeroes.
arrays = np.zeros((3, 4))
print(arrays)

for array in arrays:
	print(array)

arrays = np.zeros((1, 4))
print(arrays)

ones() method works in line with zeros()
arrays = np.ones((3, 4))
print(arrays)

for array in arrays:
	print(array)

arrays = np.ones((1, 4))
print(arrays)
-----------------------------
# Initializing a numpy Array using elements with in a range:
# arange()

array = np.arange(10, 30)
#Creates a List of elements between [10, 30) with an implicit increment of 1 between  the consecutives elements of the array.
print(array)
print(type(array))
print(array[2]) # 12
------------------------
array = np.random.randint(1, 50, 3)
# Creates an numpy array of 3 elements between the range given
print(array)

array = np.random.randint(1, 3, 3)
# The range considered is [1, 3)
# It generates 'n' number of elements which is provided as 3rd argument
# Duplicate elements may be generated
# The generated elements need not be in order
# Creates a single list of integers
print(array)

array = np.random.randint(1, 100, 15)
print(array)
array2 = sorted(array)
print(array2)
------------------------------
import numpy as np

array1 = np.array([1, 3, 5, 0, 2, 3, 4, 5, 13, 17, 23, 29])
print(array1.shape)
print(array1)

#array1.shape = (4, 2) # Error New shape of the array must consist of same number of elements as that of original array
#print(array1.shape)
#print(array1)

array1.shape = (6, 2)
print(array1.shape)
print(array1)

array1.shape = (3, 4)
print(array1.shape)
print(array1)

array1.shape = (4, 3)
print(array1.shape)
print(array1)
------------------------
a1 = np.array([22, 42, 6, 81])
a2 = np.array([30, 91, 7, 51])
a3 = np.array([0, 10, 23, 32])

# vstack()  V means Verticle. This is to place one array upon another
# vstack() takes one Arg. Thus the arrays we pass must be placed inside paranthesis
# The number of elements in all the arrays must be same
# vstack() can Stack multiple arrays

print(np.vstack((a1, a2, a3))) # place a1 on a2 and a2 on a3
print('\n')
print(np.vstack((a3, a1, a2, a1)))
-------------------------------------
a1 = np.array([2, 4])
a2 = np.array([300, 9119, 7, 5])
a3 = np.array([0, 101, 323])

# hstack() 'h' stands for horizontal
# Unlike vstack, hstack() can stack arrays of different sizes.
print(np.hstack((a1, a2)))

print(np.hstack((a1, a2, a3)))
---------------------------------
a1 = np.array([2, 4, 9])
a2 = np.array([300, 7, 5])
a3 = np.array([0, 101, 323])

# column_stack() 
# The elements from the numpy arrays, column wise are taken and a row is created.
#Note that the number of elements in the i/p arrays must be same.
print(np.column_stack((a1, a2)))

print(np.column_stack((a1, a2, a3)))
-------------------------------------
a1 = np.array([4, 9, 11, 19, 27, 31, 38, 48, 63, 85, 89, 95, 105, 119])

print(np.mean(a1))
# mean is nothing but Average, which is the quotient of sum of the elements of the array divided by number of elements in the array.
print(type(np.mean(a1)))

print(np.median(a1))
# Meadian is the middle element of the sorted list/array of the original array.
# If Even number of elements is present in the array, then the 2 mid elements are added and their average is the median.

# The mean() and Median() always returns float64 (double) type value.

# A standard deviation (or σ) is a measure of how dispersed the data is in relation to the mean. Low standard deviation means data are clustered around the mean, and high standard deviation indicates data are more spread out.
# a quantity expressing by how much the members of a group differ from the mean value for the group
#

sigma = population standard deviation
N	  =	the size of the population
ele   =	each value from the population
mu	  =	the population mean  (avg)

sq_root(sum(square(every_ele - mu)) / N)

a2 = np.array([300, 400, 350, 279, 480, 370])
print(np.std(a2))

a3 = np.array([180, 182, 185, 181, 182, 178])
print(np.std(a3))

a4 = np.array([165, 166, 165.7, 165.2, 166.15, 166.5])
print(np.std(a4))
-----------------------------------------------
a1 = np.array([2, 4, 9, 19, 7, 11])

a2 = np.array([23, 4, 9, 15, 11, 20])
# Intersection of 2 arrays (set of values)

a3 = np.array([[2, 4, 6, 7, 9, 8], [12, 21, 20, 15, 18]])
a4 = np.array([[3, 4, 9, 4, 1, 8], [12, 22, 21, 17, 13]])

a5 = np.array([[2, 4, 6], [7, 9, 8], [12, 21, 20], [15, 18, 20]])
a6 = np.array([[3, 4, 9], [2, 4, 6], [12, 21, 20], [17, 13, 20]])

a7 = np.array([[2, 4, 6], [7, 9, 8], [12, 21, 20], [15, 18, 20], [1, 2, 3]])
a8 = np.array([[3, 4, 9], [2, 4, 6], [12, 21, 20], [17, 13, 20], [1, 2, 3]])

#print(np.intersect1d(a1, a2))
print(np.intersect1d(a3, a4))
print(np.intersect1d(a5, a6))
print(np.intersect1d(a7, a8))

#for i in range(len(a3)):
#	print(np.intersect1d(a3[i], a4[i]))

# The intersect1d() returns an ORDERED SET (list or array of UNIQUE elements of 1 dimention only)
# Even if we are intersecting arrays of 2D, the intersect1d() returns a 1D list of intersecting unique elements.
# The list of intersecting unique elements returned by intersect1d() is always ordered.
# If there are no common elements between the i/p lists, then intersect1d() returns an empty list
-------------------------------
import numpy as np

mysore_stores = ['tata', 'patanjali', 'itc', 'dabur', 'metro', 'reliance']
neeraja_visited = (['itc', 'itc,', 'dabur', 'dabur', 'itc', 'patanjali', 'metro', 'patanjali', 'metro', 'ajay_stores'])

x = 0
visited_stores = np.zeros((1, len( mysore_stores )))

for i in range(len(neeraja_visited)):
	if neeraja_visited[i] in mysore_stores:
		index = mysore_stores.index(neeraja_visited[i])
		if index != -1:
            visited_stores[0][index] = 1

for element in visited_stores[0]:
	if element == 1:
		x += 1

print(f'Number of stores visited by Neeraja is {x}')
---------------------------------------
a1 = np.array([2, 4, 9, 19, 7, 11])
a2 = np.array([2, 14, 9, 29, 72, 111])

print(np.setdiff1d(a1, a2)) # 4, 9, 7, 11
# a1 - a2, i.e. prints the elements which are in a1 but not in a2

print(np.setdiff1d(a2, a1)) # 14, 29, 72, 111
# a2 - a1, i.e. prints the elements which are in a2 but not in a1
---------------------------------------------------
# Numpy arrays as Matrices
print(a1[0]) # To print the 1st row in the Matrix
print(a2[1])

print(a1[:, 1]) # To print 2nd Column in the matrix
print(a2[:, 2]) # # To print 3rd Column in the matrix
----------------------------------------------------
# Arithmetic operations on Numpy Arrays

a3 = np.array([2, 4, 6, 8])
a4 = np.array([1, 3, 5, 7])
a5 = a3 + a4
a7 = a3 - a4
a6 = a4 - 3
a3 = a3 + 1
a4 = a4 + 2
a8 = a3 * 3
print('A8 = ', a8)
print('A6 = ', a6)
print('A7 = ', a7)
print('A3 = ', a3)
print('A4 = ', a4)
print('A5 = ', a5)

l1 = [2, 4, 5]
print('\n', l1 * 3)
a5 = a3 / 4
print(a5) # prints the quotient with precision
---------------------------------------------------------
import csv
import numpy as np

data = [] # Normal or ordinary list

with open('data1.csv', 'r') as csvfile:
    file_reader = csv.reader(csvfile, delimiter = ',')
    for row in file_reader:
        data.append(row)

npdata = np.array(data)  # convert the ordinary list of lists to a NumPy array which is 1D

print(len(npdata), '\n', type(npdata))
print('Shape: ', npdata.shape)
print('Datatype: ', npdata.dtype.type)
np.save(open('data2.npy', 'wb'), npdata) #We are saving the np array into a file with extension .npy

for element in data:
    print(element)
----------------------------------------------------------
import numpy as np

list1 = [
    [ int(x) for x in range(1, 20, 2) ],
    [ int(x) for x in range(20, 40, 2) ],
    [ int(x) for x in range(41, 60, 2) ],
    [ int(x) for x in range(60, 80, 2) ]
]

np_array = np.array(list1)

for array in np_array:
    print(array)

print('Length: ', len(np_array))
print('Type: ', type(np_array))
print('Shape: ', np_array.shape)
print('Datatype: ', np_array.dtype.type)
print('Size: ', np_array.size)
----------------------------------------------------------
import numpy as np

list1 = [
    [ int(x) for x in range(1, 20, 2) ],
    [ int(x) for x in range(20, 40, 2) ],
    [ int(x) for x in range(41, 60, 2) ],
    [ int(x) for x in range(60, 80, 2) ]
]

np_array = np.array(list1)
for array in np_array:
    print(array)

print('np_array[1, 2:4]: ', np_array[1, 2:4]) # 2nd row 3rd and 4th elements
print('np_array[:, 1]: ', np_array[:, 1]) # All the rows, 2nd column elements
print('np_array[2:, 2:]: ', np_array[2:, 2:]) # From 3rd row till last row, in each row, print from 3rd
# column till last. Hence, you should get 2D Array
print('np_array[1::2, ::2] \n', np_array[1::2, ::2]) # In 2nd Row, alternate elements and in Last row
# alternate elements
print('np_array[0:10, 4]', np_array[0:10, 4]) # From rows indexed 0 to 9, print all the elements in 
# column index 4
print('np_array[:,4]', np_array[:,4]) # All rows, 5th column elements

print('np_array[:,2:4] \n', np_array[:,2:4]) # From all rows, consider elements from column indexed 2 to 3
# Thus we get 2D numpy Array

subset = np_array[1:6, [2, 3, 7]] #Start from 2nd row till 6th row and print the elements in
# column indices 2, 3 and 7

print('Subset:\n', subset)
-----------------------------------------------------------
Attributes of an Array
The reshape() Method
The flatten() Method
Working with Arrays using numpy
Creating Arrays using array()
Creating Arrays using linspace
Creating Arrays using logspace
Creating Arrays using arange() Function
Creating Arrays using zeros() and ones() Functions
Mathematical Operations on Arrays
Comparing Arrays
-------------------
The assert Statement
The Global Keyword
Anonymous Functions or Lambdas
Function Decorators
Generators
Creating our Own Modules in Python
---------------------------------------------------------------
EXCEPTION HANDLING:
When a error occurs at runtime, it is called as an Exception.
Thus exception is the error which cannot be found by the compiler.
Exception = RunTimeError

When an exception occurs, the normal flow of code cannot be continued.
Thus, the Python Interpreter stops the execution and THROWS the respective exception created.

We say an Exception occured, which means in the code, the present instruction is trying to do something which is impossible.
e.g:
1. Trying to access 5th element in the list which has 4 elements.
2. Trying to store the quotient of a division where the divider is zero.
3. Trying to connect to the DB which is switched off.
4. Trying to open a file for reading which doesn't exist.

When an exception occurs, an object of a respective Exception class is created and it is thrown.

Now, if nobody CATCH this exception object, then the interpreter stops the program execution by displaying the exception class.

HANDLING AN EXCEPTION:
Stopping the program execution abtruptly creates havoc with the user.
Hence we need a mechanism where we can HANDLE the exception within the code and give the possible solution when an exception occurs.

IMPLEMENTATION OF EXCEPTION HANDLING:
The code where we SUSPECT that exception may occur must be put into "try" block
And the solution(s) for the exception if occurs must be put into "except" blocks(s).
Note that the try-except blocks are defined inside a method/function.

WHEN EXCEPTION DOESN'T OCCUR:
When exception doesn't occur, all the statements of the "try" block runs and all the "except" blocks are skipped and the "finally" block statements are run (if present) and lastly the statements at the end of the function (after the except and finally blocks) are run (if present).

WHEN EXCEPTION OCCURS:
The statement inside the try block which creates the exception is not SUCCESSFULLY run. Hence, the control comes out of the try block, thus skipping the remaining statements inside the try block and an object of a respective exception class is created and it is thrown.
Now this object is matched one by one with the except blocks in the order they are defined (similar to switch-case matching).

If none of the except blocks match with the exception object, then the interpreter will stop the program execution and displays the exception type.

Note that the exception object created in the try block can be received by a super-class type (exception class type reference).
** Hence the except blocks types if are is-a related (inheritance), then the sub type except block must be defined before the super type except blocks (i.e., in the reverse order of derivation)

Note: It is always safe to define the parent-most except block, i.e., of the type Exception.

Note:
1. Inside the except blocks, we can again define try-except blocks.
2. We can define a try block inside a try block (nesting). Advantage of doing so is that, if none of the except blocks of inner try matches the exception object, then the matching is continued with the except blocks of the outer try.
3. A try block must have at least one except block.
4. There cannot be any statements inbetween the try and except blocks.
5. except block(s) cannot exist without a try
** 6. finally block is optional. But if present, it runs irrespective of whether the exception occured or not.
7. Only one finally block can be defined for each try block.
8. The inner/nested except and finally blocks of the nested try block runs only if the control goes to the inner/nested try block.

def someFunction():
	try:
		num = 45 / 0
	except ZeroDivisionError:
		print('You tried divinding a number by Zero')
	finally:
		print('From Finally of 1st try block')
	print('After 1st set of try-except-finally blocks')
	try:
		list1 = []
		# num = list1[1] # Exception occurs
	except IndexError:
		print('You tried to access an element beyond list size')
	finally:
		print('From Finally of 2nd try block')
	print('After 2nd set of try-except-finally blocks')

# Main block
someFunction()
-----------------------------------------
def someFunction():
	try:
		print('From the 1st outer try block')
		try:
			print('from the nexted try block')
		except Exception:
			print('from the nexted except block')
		finally:
			print('from the nexted finally block')
	except ZeroDivisionError:
		print('You tried divinding a number by Zero')
	finally:
		print('From Finally of 1st try block')
	print('After 1st set of try-except-finally blocks')
	try:
		list1 = []
		# num = list1[1] # Exception occurs
	except IndexError:
		print('You tried to access an element beyond list size')
	finally:
		print('From Finally of 2nd try block')
	print('After 2nd set of try-except-finally blocks')

# Main block
someFunction()
-----------------------------------------------
hello = input()
print1(hello)
#NameError: name 'print1' is not defined
# Any name/identifier in the code, say a variable or def or class etc. which is not defined, but being accessed causes NameError

num1 = input('Enter a number: ')
num2 = int(input('Enter a number: '))

sum = num1 + num2 # Note that there is no implicit cast in Python
# TypeError: can only concatenate str (not "int") to str`
print(sum)
---------------
nithin = print('Nithin') # print() returns nothing
print(nithin) #None
print(len(nithin))
#TypeError: object of type 'NoneType' has no len()
----------------------------------
num1 = 17
num2 = 0
num3 = num1/num2 # Error
print(num3)
# ZeroDivisionError: division by zero
----------------------------
import math
root = math.sqrt(-20)
print(f'Root = {root}')
# ValueError: math domain error

import math
try:
	root = math.sqrt(-20)
	print(f'Root = {root}')
except ValueError:
	print('You gave a wrong Type of value')
# ValueError: math domain error
------------------------------
list1 = [1, 4, 8]
for i in range(5):
	print(list1[i])
# IndexError: list index out of range
-----------------------------
AssertionError:
Raised when the assert statement fails.
AttributeError:
Raised on the attribute assignment or reference fails.
EOFError:
Raised when the input() function hits the end-of-file condition.
FloatingPointError:
Raised when a floating point operation fails.
GeneratorExit:
Raised when a generator's close() method is called.
ImportError:
Raised when the imported module is not found.
IndexError:
Raised when the index of a sequence is out of range.
KeyError:
Raised when a key is not found in a dictionary.
KeyboardInterrupt:
Raised when the user hits the interrupt key (Ctrl+c or delete).
MemoryError:
Raised when an operation runs out of memory.
NameError:
Raised when a variable is not found in the local or global scope.
NotImplementedError:
Raised by abstract methods.
OSError:
Raised when a system operation causes a system-related error.
OverflowError:
Raised when the result of an arithmetic operation is too large to be represented.
ReferenceError:
Raised when a weak reference proxy is used to access a garbage collected referent.
RuntimeError:
Raised when an error does not fall under any other category.
StopIteration:
Raised by the next() function to indicate that there is no further item to be returned by the iterator.
SyntaxError:
Raised by the parser when a syntax error is encountered.
IndentationError:
Raised when there is an incorrect indentation.
TabError:
Raised when the indentation consists of inconsistent tabs and spaces.
SystemError:
Raised when the interpreter detects internal error.
SystemExit:
Raised by the sys.exit() function.
TypeError:
Raised when a function or operation is applied to an object of an incorrect type.
UnboundLocalError:
Raised when a reference is made to a local variable in a function or method, but no value has been bound to that variable.
UnicodeError:
Raised when a Unicode-related encoding or decoding error occurs.
UnicodeEncodeError:
Raised when a Unicode-related error occurs during encoding.
UnicodeDecodeError:
Raised when a Unicode-related error occurs during decoding.
UnicodeTranslateError:
Raised when a Unicode-related error occurs during translation.
ValueError:
Raised when a function gets an argument of correct type but improper value.
ZeroDivisionError:
Raised when the second operand of a division or module operation is zero.


1.
a = ["Python", "Exceptions", "try and except"]  
try:  
     for i in range(4):  
        print( "The index and element from the array is", i, a[i] )  
except:  
    print ("Index out of range")  
print ("Out of try catch block")
--------------------------------------
2.
def check(list1, name):
	try:
		total = 0
		for ele in list1:
			total += int(ele)
		avg = total // len(list1)
		pwd = avg + name
		return int(pwd)
	except ValueError:
		print('Value error while check')
	except TypeError:
		print('Type error while check')
	except NameError:
		print('Name error while check')
	finally:
		print('Finally in called function')
	print('From end of inside of method')

list1 = [10, 20, 30, 40, 50, 60, '7A']
try:
	check(list1, 'ABC')
except NameError:
	print('Name error in Main')
finally:
	print('Finally in Main')
-----------------------------------------
3.
class NonDivisibilityException(Exception):
	pass

class NonPositiveException(Exception):
	pass

class CheckStatus:
	def is_div_by_two(self, list1):
		try:
			for value in list1:
				if value % 2 != 0:
					raise NonDivisibilityException()
				if value < 0:
					raise NonPositiveException()
			print('Divisible by 2')
		except NonDivisibilityException:
			print('Number excetpion - Inside')
		print('Inside Method')

# Main Code:
try:
	CheckStatus().is_div_by_two([3, -8, 12, 4])
	print('Inside Main')
except NonDivisibilityException:
	print('Number exception - Outside')
except Exception as e:
	print('Some Error occured')
finally:
	print('From Inside Finally of Main')
print('Program Over')
--------------------------------------
4.
class B(Exception):
    pass

class C(B):
    pass

class D(C):
    pass

for cls in [B, C, D]:
    try:
        raise cls()
    except D:
        print("D")
    except C:
        print("C")
    except B:
        print("B")
-------------------------------------
try:
    raise Exception('spam', 'eggs')
except Exception as inst:
    print(type(inst))    # the exception instance
    print(inst.args)     # arguments stored in .args
    print(inst)          # __str__ allows args to be printed directly,
                         # but may be overridden in exception subclasses
    x, y = inst.args     # unpack args
    print('x =', x)
    print('y =', y)

<class 'Exception'>
('spam', 'eggs')
('spam', 'eggs')
x = spam
y = eggs
--------------------------------------------
PANDAS MATERIAL:

NumPy (Under the hood of Pandas, lies NumPy)
Matplotlib (Data Visualization)
SciPy (Statistical Analysis)
Scikit-learn (Machine Learning)

Here is a list of things that we can do using Pandas:
Data set cleaning, merging, and joining.
Easy handling of missing data (represented as NaN) in floating point as well as non-floating point data.
Columns can be inserted and deleted from DataFrame and higher dimensional objects.
Powerful group by functionality for performing split-apply-combine operations on data sets.
Data Visulaization

pip install pandas

import pandas as pd

# import pandas as pd
import pandas as pd
 
# simple array
 
ser = pd.Series(data)
print(ser)
----------------------------------------------
To convert a python list into a numpy array

import numpy as np

# create a list named list1
list1 = [2, 4, 6, 8]

# create numpy array using list1
array1 = np.array(list1)

print(array1)

# Output: [2 4 6 8]
---------------------------------------
import numpy as np

# create a 2D array with 2 rows and 4 columns
array1 = np.array([[1, 2, 3, 4],
                  [5, 6, 7, 8]])

print(array1)
--------------------------------
numpy DTs
int8, int16, int32, int64 - signed integer types with different bit sizes
uint8, uint16, uint32, uint64 - unsigned integer types with different bit sizes
float32, float64 - floating-point types with different precision levels
complex64, complex128 - complex number types with different precision levels
-------------------------------
Converting a NumPy array into a CSV file

np.savetxt("arr.csv", arr, delimiter=",")

# Import numpy
import numpy as np

# Creating a Numpy arrays
arr = np.array([ [1,2,3], [4,5,6], [7,8,9] ])

# Display original numpy array
print("Original Numpy array:\n",arr,"\n")

# Dumping this array into a csv file
np.savetxt("arr.csv", arr, delimiter=",")

# Display a msg
print("File Saved:\n")
------------------------------------------------------------
Convert float array to int array using ceil() method

import numpy as np

# Creating a numpy array
arr = np.array( [ 8.99, 8.01, 8.5, 8.0, 8.32, 8.88 ] )

# Display original array
print("Orignal array:\n",arr,"\n")

# Using ceil() method
res = np.ceil(arr)

# Display result
print("Result:\n",res)
-------------------------------------------------
Find max and min in an numpy array:

import numpy as np

# Creating 5x4 array
array = np.arange(20).reshape(5, 4)
print(array)
print()

# If no axis mentioned, then it works on the entire array
print(np.argmax(array))

# If axis=1, then it works on each row
print(np.argmax(array, axis=1))

# If axis=0, then it works on each column
print(np.argmax(array, axis=0))
--------------------------------------------------------
How to sort the elements in the given array using Numpy?

import numpy as np

array = np.array([
    [3, 7, 1],
    [10, 3, 2],
    [5, 6, 7]
])
print(array)
print()

# Sort the whole array
print(np.sort(array, axis=None))

# Sort along each row
print(np.sort(array, axis=1))

# Sort along each column
print(np.sort(array, axis=0))
--------------------------------------------------------
How to find the mean of every NumPy array in the given list?

import numpy as np

list = [
    np.array([3, 2, 8, 9]),
    np.array([4, 12, 34, 25, 78]),
    np.array([23, 12, 67])
]

result = []
for i in range(len(list)):
    result.append(np.mean(list[i]))
print(result)

--------------------------------------------------------
How to add rows and columns in NumPy array?

import numpy as np

array = np.array([
    [3, 2, 8],
    [4, 12, 34],
    [23, 12, 67]
])

newRow = np.array([2, 1, 8])
newArray = np.vstack((array, newRow))
print(newArray)

--------------------------------------------------------
How to reverse a NumPy array?

import numpy as np

array = np.array([3, 6, 7, 2, 5, 1, 8])
reversedArray = np.flipud(array)
print(reversedArray)

--------------------------------------------------------
How to multiply two matrices in a single line using NumPy?

import numpy as np

matrix1 = [
    [3, 4, 2],
    [5, 1, 8],
    [3, 1, 9]
]

matrix2 = [
    [3, 7, 5],
    [2, 9, 8],
    [1, 5, 8]
]

result = np.dot(matrix1, matrix2)
print(result)

--------------------------------------------------------
How to print the checkerboard pattern of nxn using NumPy?

import numpy as np

n = 8

# Create a nxn matrix filled with 0
matrix = np.zeros((n, n), dtype=int)

# fill 1 with alternate rows and column
matrix[::2, 1::2] = 1
matrix[1::2, ::2] = 1

# Print the checkerboard pattern
for i in range(n):
    for j in range(n):
        print(matrix[i][j], end=" ")
    print()

--------------------------------------------------------
Python Program to Convert List of Lists to NumPy Array

# Import NumPy
import numpy as np

# Creating a nested list (list of lists)
l = [[1, 2], [3, 4], [5, 6]]

# Printing list of lists and its type
print("List of lists (l):\n", l, "\n")
print("Type of l:", type(l), "\n")

# Converting list of lists to NumPy array
arr = np.array(l)

# Printing NumPy array
print("Result: NumPy Array (arr):\n", arr, "\n")
print("Type of arr:", type(arr), "\n")


--------------------------------------------------------
How to remove NaN values from a given NumPy array?

# Import numpy
import numpy as np

# Creating a numpy array
arr = np.array([1, 2, np.NaN, 4, np.NaN, 8])

# Display original array
print("Orignal array:\n",arr,"\n")

# Extracting non null values
res = arr[~np.isnan(arr)]

# Display Result
print("Result:\n",res,"\n")
--------------------------------------------------------
p2.py
import pymysql
def connectDb():
	try:
		connectionObject = pymysql.Connect(host='localhost', port=3306, user='root', password='Root123', db='nithin_db', charset='utf8')
		print('Database connected successfully')
		return connectionObject
	except:
		print('Database connectivity Failed')
		
def disConnectDb(connection):
    connection.close()
    print('Database disconnected successfully')

connectionObject = connectDb()
disConnectDb(connectionObject)
----------------------------------------------------
p9.py

import pymysql
def connectDb():
	try:
		connectionObject = pymysql.Connect(host='localhost', port=3306, user='root', password='Root123', db='nithin_db', charset='utf8')
		print('Database connected successfully')
		return connectionObject
	except:
		print('Database connectivity Failed')
		
def disConnectDb(connectionObject):
    connectionObject.close()
    print('Database disconnected successfully')

def listAllGames():
    query = f'select * from games'
	try:
		connection = connectDb()
        cursor = connection.cursor()
        numberOfRows = cursor.execute(query)
        connection.commit()
        rows = cursor.fetchall()
        if rows is None:
			print(f'Game with id = {id} not found')
		else:
			for row in rows:
				print('Game Details is: \n', str(row))
            cursor.close()
            disConnectDb(connection)
        except pymysql.err.DataError:
            print('Row Listing failed')

connectionObject = connectDb()
connectionObject.listAllGames()
disConnectDb(connectionObject)
----------------------------------------------------------
